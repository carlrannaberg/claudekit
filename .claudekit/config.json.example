{
  "hooks": {
    "self-review": {
      "targetPatterns": [
        "**/*.ts",
        "**/*.tsx", 
        "**/*.js",
        "**/*.jsx",
        "!**/*.test.*",
        "!**/*.spec.*",
        "!**/tests/**",
        "!**/docs/**",
        "!**/*.md"
      ],
      "focusAreas": [
        {
          "name": "Implementation Completeness",
          "questions": [
            "Did you create a mock implementation just to pass tests instead of real functionality?",
            "Are there any 'Not implemented yet' placeholders or TODO comments in production code?",
            "Does the implementation actually do what it claims, or just return hardcoded values?",
            "Did you stub out functionality with placeholder messages instead of real logic?",
            "Are all the features actually working, or just pretending to work?",
            "Did you implement the full solution or just the minimum to make tests green?",
            "Did you finish what you started or leave work half-done?"
          ]
        },
        {
          "name": "Testing",
          "questions": [
            "Did you add tests for the new functionality you implemented?",
            "Are your tests actually testing the behavior, or just that functions exist?",
            "Did you test edge cases and error conditions?",
            "Are the tests meaningful or just added to increase coverage?",
            "Would the tests catch real bugs if someone broke the implementation?",
            "Did you verify that the tests actually fail when the implementation is wrong?"
          ]
        },
        {
          "name": "Code Quality",
          "questions": [
            "Did you leave the code better than you found it?",
            "Is there duplicated logic that should be extracted?",
            "Are you using different patterns than the existing code uses?",
            "Is the code more complex now than it needs to be?",
            "Did you clean up after making your changes work?",
            "Is every piece of code still serving a clear purpose?"
          ]
        },
        {
          "name": "Integration & Refactoring",
          "questions": [
            "Did you just add code on top without integrating it properly?",
            "Should you extract the new functionality into cleaner abstractions?",
            "Would refactoring the surrounding code make everything simpler?",
            "Does the code structure still make sense after your additions?",
            "Should you consolidate similar functions that now exist?",
            "Did you leave any temporary workarounds or hacks?"
          ]
        },
        {
          "name": "Codebase Consistency",
          "questions": [
            "Should other parts of the codebase be updated to match your improvements?",
            "Did you update all the places that depend on what you changed?",
            "Are there related files that need the same changes?",
            "Did you create a utility that existing code could benefit from?",
            "Should your solution be applied elsewhere for consistency?",
            "Are you following the same patterns used elsewhere in the codebase?"
          ]
        }
      ]
    },
    "typecheck-changed": {
      "command": "npx tsc --noEmit",
      "timeout": 30000
    },
    "typecheck-project": {
      "command": "npx tsc --noEmit"
    },
    "lint-changed": {
      "command": "npx eslint",
      "fix": false,
      "extensions": [".js", ".jsx", ".ts", ".tsx"],
      "timeout": 30000
    },
    "lint-project": {
      "command": "npx eslint . --ext .js,.jsx,.ts,.tsx"
    },
    "test-changed": {
      "command": "npm test"
    },
    "test-project": {
      "command": "npm test",
      "timeout": 50000
    },
    "create-checkpoint": {
      "prefix": "claude",
      "maxCheckpoints": 10
    }
  }
}